import { LRUCache } from 'lru-cache';
import { EppoValue } from './eppo_value';
export interface AssignmentCacheKey {
    subjectKey: string;
    flagKey: string;
    allocationKey: string;
    variationValue: EppoValue;
}
export interface Cacheable {
    get(key: string): string | undefined;
    set(key: string, value: string): void;
    has(key: string): boolean;
}
export declare abstract class AssignmentCache<T extends Cacheable> {
    protected cache: T;
    constructor(cacheInstance: T);
    hasLoggedAssignment(key: AssignmentCacheKey): boolean;
    setLastLoggedAssignment(key: AssignmentCacheKey): void;
    protected getCacheKey({ subjectKey, flagKey, allocationKey }: AssignmentCacheKey): string;
}
/**
 * A cache that never expires.
 *
 * The primary use case is for client-side SDKs, where the cache is only used
 * for a single user.
 */
export declare class NonExpiringAssignmentCache extends AssignmentCache<Map<string, string>> {
    constructor();
}
/**
 * A cache that uses the LRU algorithm to evict the least recently used items.
 *
 * It is used to limit the size of the cache.
 *
 * The primary use case is for server-side SDKs, where the cache is shared across
 * multiple users. In this case, the cache size should be set to the maximum number
 * of users that can be active at the same time.
 */
export declare class LRUAssignmentCache extends AssignmentCache<LRUCache<string, string>> {
    constructor(maxSize: number);
}
//# sourceMappingURL=assignment-cache.d.ts.map