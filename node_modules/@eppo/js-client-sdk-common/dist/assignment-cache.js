"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LRUAssignmentCache = exports.NonExpiringAssignmentCache = exports.AssignmentCache = void 0;
const lru_cache_1 = require("lru-cache");
class AssignmentCache {
    constructor(cacheInstance) {
        this.cache = cacheInstance;
    }
    hasLoggedAssignment(key) {
        // no cache key present
        if (!this.cache.has(this.getCacheKey(key))) {
            return false;
        }
        // the subject has been assigned to a different variation
        // than was previously logged.
        // in this case we need to log the assignment again.
        if (this.cache.get(this.getCacheKey(key)) !== key.variationValue.toHashedString()) {
            return false;
        }
        return true;
    }
    setLastLoggedAssignment(key) {
        this.cache.set(this.getCacheKey(key), key.variationValue.toHashedString());
    }
    getCacheKey({ subjectKey, flagKey, allocationKey }) {
        return [`subject:${subjectKey}`, `flag:${flagKey}`, `allocation:${allocationKey}`].join(';');
    }
}
exports.AssignmentCache = AssignmentCache;
/**
 * A cache that never expires.
 *
 * The primary use case is for client-side SDKs, where the cache is only used
 * for a single user.
 */
class NonExpiringAssignmentCache extends AssignmentCache {
    constructor() {
        super(new Map());
    }
}
exports.NonExpiringAssignmentCache = NonExpiringAssignmentCache;
/**
 * A cache that uses the LRU algorithm to evict the least recently used items.
 *
 * It is used to limit the size of the cache.
 *
 * The primary use case is for server-side SDKs, where the cache is shared across
 * multiple users. In this case, the cache size should be set to the maximum number
 * of users that can be active at the same time.
 */
class LRUAssignmentCache extends AssignmentCache {
    constructor(maxSize) {
        super(new lru_cache_1.LRUCache({ max: maxSize }));
    }
}
exports.LRUAssignmentCache = LRUAssignmentCache;
//# sourceMappingURL=assignment-cache.js.map