"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findMatchingRule = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const rule_dto_1 = require("./dto/rule-dto");
const obfuscation_1 = require("./obfuscation");
function findMatchingRule(subjectAttributes, rules, obfuscated) {
    for (const rule of rules) {
        if (matchesRule(subjectAttributes, rule, obfuscated)) {
            return rule;
        }
    }
    return null;
}
exports.findMatchingRule = findMatchingRule;
function matchesRule(subjectAttributes, rule, obfuscated) {
    const conditionEvaluations = evaluateRuleConditions(subjectAttributes, rule.conditions, obfuscated);
    return !conditionEvaluations.includes(false);
}
function evaluateRuleConditions(subjectAttributes, conditions, obfuscated) {
    return conditions.map((condition) => obfuscated
        ? evaluateObfuscatedCondition(subjectAttributes, condition)
        : evaluateCondition(subjectAttributes, condition));
}
function evaluateCondition(subjectAttributes, condition) {
    const value = subjectAttributes[condition.attribute];
    if (value != null) {
        switch (condition.operator) {
            case rule_dto_1.OperatorType.GTE:
                return compareNumber(value, condition.value, (a, b) => a >= b);
            case rule_dto_1.OperatorType.GT:
                return compareNumber(value, condition.value, (a, b) => a > b);
            case rule_dto_1.OperatorType.LTE:
                return compareNumber(value, condition.value, (a, b) => a <= b);
            case rule_dto_1.OperatorType.LT:
                return compareNumber(value, condition.value, (a, b) => a < b);
            case rule_dto_1.OperatorType.MATCHES:
                return new RegExp(condition.value).test(value);
            case rule_dto_1.OperatorType.ONE_OF:
                return isOneOf(value.toString().toLowerCase(), condition.value.map((value) => value.toLowerCase()));
            case rule_dto_1.OperatorType.NOT_ONE_OF:
                return isNotOneOf(value.toString().toLowerCase(), condition.value.map((value) => value.toLowerCase()));
        }
    }
    return false;
}
function evaluateObfuscatedCondition(subjectAttributes, condition) {
    const hashedSubjectAttributes = Object.entries(subjectAttributes).reduce((accum, [key, val]) => (Object.assign({ [(0, obfuscation_1.getMD5Hash)(key)]: val }, accum)), {});
    const value = hashedSubjectAttributes[condition.attribute];
    if (value != null) {
        switch (condition.operator) {
            case (0, obfuscation_1.getMD5Hash)(rule_dto_1.OperatorType.GTE):
                return compareNumber(value, Number((0, obfuscation_1.decodeBase64)(condition.value)), (a, b) => a >= b);
            case (0, obfuscation_1.getMD5Hash)(rule_dto_1.OperatorType.GT):
                return compareNumber(value, Number((0, obfuscation_1.decodeBase64)(condition.value)), (a, b) => a > b);
            case (0, obfuscation_1.getMD5Hash)(rule_dto_1.OperatorType.LTE):
                return compareNumber(value, Number((0, obfuscation_1.decodeBase64)(condition.value)), (a, b) => a <= b);
            case (0, obfuscation_1.getMD5Hash)(rule_dto_1.OperatorType.LT):
                return compareNumber(value, Number((0, obfuscation_1.decodeBase64)(condition.value)), (a, b) => a < b);
            case (0, obfuscation_1.getMD5Hash)(rule_dto_1.OperatorType.MATCHES):
                return new RegExp((0, obfuscation_1.decodeBase64)(condition.value)).test(value);
            case (0, obfuscation_1.getMD5Hash)(rule_dto_1.OperatorType.ONE_OF):
                return isOneOf((0, obfuscation_1.getMD5Hash)(value.toString().toLowerCase()), condition.value);
            case (0, obfuscation_1.getMD5Hash)(rule_dto_1.OperatorType.NOT_ONE_OF):
                return isNotOneOf((0, obfuscation_1.getMD5Hash)(value.toString().toLowerCase()), condition.value);
        }
    }
    return false;
}
function isOneOf(attributeValue, conditionValue) {
    return getMatchingStringValues(attributeValue, conditionValue).length > 0;
}
function isNotOneOf(attributeValue, conditionValue) {
    return getMatchingStringValues(attributeValue, conditionValue).length === 0;
}
function getMatchingStringValues(attributeValue, conditionValues) {
    return conditionValues.filter((value) => value === attributeValue);
}
function compareNumber(attributeValue, conditionValue, compareFn) {
    return (typeof attributeValue === 'number' &&
        typeof conditionValue === 'number' &&
        compareFn(attributeValue, conditionValue));
}
//# sourceMappingURL=rule_evaluator.js.map