"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const md5 = require("md5");
const assignment_cache_1 = require("../assignment-cache");
const constants_1 = require("../constants");
const eppo_value_1 = require("../eppo_value");
const obfuscation_1 = require("../obfuscation");
const rule_evaluator_1 = require("../rule_evaluator");
const shard_1 = require("../shard");
const validation_1 = require("../validation");
class EppoClient {
    constructor(configurationStore) {
        this.configurationStore = configurationStore;
        this.queuedEvents = [];
        this.isGracefulFailureMode = true;
    }
    // @deprecated getAssignment is deprecated in favor of the typed get<Type>Assignment methods
    getAssignment(subjectKey, flagKey, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    subjectAttributes = {}, assignmentHooks, obfuscated = false) {
        var _a;
        try {
            return ((_a = this.getAssignmentVariation(subjectKey, flagKey, subjectAttributes, assignmentHooks, obfuscated).stringValue) !== null && _a !== void 0 ? _a : null);
        }
        catch (error) {
            return this.rethrowIfNotGraceful(error);
        }
    }
    getStringAssignment(subjectKey, flagKey, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    subjectAttributes = {}, assignmentHooks, obfuscated = false) {
        var _a;
        try {
            return ((_a = this.getAssignmentVariation(subjectKey, flagKey, subjectAttributes, assignmentHooks, obfuscated, eppo_value_1.ValueType.StringType).stringValue) !== null && _a !== void 0 ? _a : null);
        }
        catch (error) {
            return this.rethrowIfNotGraceful(error);
        }
    }
    getBoolAssignment(subjectKey, flagKey, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    subjectAttributes = {}, assignmentHooks, obfuscated = false) {
        var _a;
        try {
            return ((_a = this.getAssignmentVariation(subjectKey, flagKey, subjectAttributes, assignmentHooks, obfuscated, eppo_value_1.ValueType.BoolType).boolValue) !== null && _a !== void 0 ? _a : null);
        }
        catch (error) {
            return this.rethrowIfNotGraceful(error);
        }
    }
    getNumericAssignment(subjectKey, flagKey, subjectAttributes, assignmentHooks, obfuscated = false) {
        var _a;
        try {
            return ((_a = this.getAssignmentVariation(subjectKey, flagKey, subjectAttributes, assignmentHooks, obfuscated, eppo_value_1.ValueType.NumericType).numericValue) !== null && _a !== void 0 ? _a : null);
        }
        catch (error) {
            return this.rethrowIfNotGraceful(error);
        }
    }
    getJSONStringAssignment(subjectKey, flagKey, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    subjectAttributes = {}, assignmentHooks, obfuscated = false) {
        var _a;
        try {
            return ((_a = this.getAssignmentVariation(subjectKey, flagKey, subjectAttributes, assignmentHooks, obfuscated, eppo_value_1.ValueType.JSONType).stringValue) !== null && _a !== void 0 ? _a : null);
        }
        catch (error) {
            return this.rethrowIfNotGraceful(error);
        }
    }
    getParsedJSONAssignment(subjectKey, flagKey, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    subjectAttributes = {}, assignmentHooks, obfuscated = false) {
        var _a;
        try {
            return ((_a = this.getAssignmentVariation(subjectKey, flagKey, subjectAttributes, assignmentHooks, obfuscated, eppo_value_1.ValueType.JSONType).objectValue) !== null && _a !== void 0 ? _a : null);
        }
        catch (error) {
            return this.rethrowIfNotGraceful(error);
        }
    }
    rethrowIfNotGraceful(err) {
        if (this.isGracefulFailureMode) {
            console.error(`[Eppo SDK] Error getting assignment: ${err.message}`);
            return null;
        }
        throw err;
    }
    getAssignmentVariation(subjectKey, flagKey, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    subjectAttributes = {}, assignmentHooks, obfuscated, valueType) {
        const { allocationKey, assignment } = this.getAssignmentInternal(subjectKey, flagKey, subjectAttributes, assignmentHooks, obfuscated, valueType);
        assignmentHooks === null || assignmentHooks === void 0 ? void 0 : assignmentHooks.onPostAssignment(flagKey, subjectKey, assignment, allocationKey);
        if (!assignment.isNullType() && allocationKey !== null)
            this.logAssignment(flagKey, allocationKey, assignment, subjectKey, subjectAttributes);
        return assignment;
    }
    getAssignmentInternal(subjectKey, flagKey, subjectAttributes = {}, assignmentHooks, obfuscated, expectedValueType) {
        (0, validation_1.validateNotBlank)(subjectKey, 'Invalid argument: subjectKey cannot be blank');
        (0, validation_1.validateNotBlank)(flagKey, 'Invalid argument: flagKey cannot be blank');
        const nullAssignment = { allocationKey: null, assignment: eppo_value_1.EppoValue.Null() };
        const experimentConfig = this.configurationStore.get(obfuscated ? (0, obfuscation_1.getMD5Hash)(flagKey) : flagKey);
        const allowListOverride = this.getSubjectVariationOverride(subjectKey, experimentConfig, expectedValueType);
        if (!allowListOverride.isNullType()) {
            if (!allowListOverride.isExpectedType()) {
                return nullAssignment;
            }
            return Object.assign(Object.assign({}, nullAssignment), { assignment: allowListOverride });
        }
        // Check for disabled flag.
        if (!(experimentConfig === null || experimentConfig === void 0 ? void 0 : experimentConfig.enabled))
            return nullAssignment;
        // check for overridden assignment via hook
        const overriddenAssignment = assignmentHooks === null || assignmentHooks === void 0 ? void 0 : assignmentHooks.onPreAssignment(flagKey, subjectKey);
        if (overriddenAssignment !== null && overriddenAssignment !== undefined) {
            if (!overriddenAssignment.isExpectedType())
                return nullAssignment;
            return Object.assign(Object.assign({}, nullAssignment), { assignment: overriddenAssignment });
        }
        // Attempt to match a rule from the list.
        const matchedRule = (0, rule_evaluator_1.findMatchingRule)(subjectAttributes || {}, experimentConfig.rules, obfuscated);
        if (!matchedRule)
            return nullAssignment;
        // Check if subject is in allocation sample.
        const allocation = experimentConfig.allocations[matchedRule.allocationKey];
        if (!this.isInExperimentSample(subjectKey, flagKey, experimentConfig, allocation))
            return nullAssignment;
        // Compute variation for subject.
        const { subjectShards } = experimentConfig;
        const { variations } = allocation;
        const shard = (0, shard_1.getShard)(`assignment-${subjectKey}-${flagKey}`, subjectShards);
        const assignedVariation = variations.find((variation) => (0, shard_1.isShardInRange)(shard, variation.shardRange));
        const internalAssignment = {
            allocationKey: matchedRule.allocationKey,
            assignment: eppo_value_1.EppoValue.generateEppoValue(expectedValueType, assignedVariation === null || assignedVariation === void 0 ? void 0 : assignedVariation.value, assignedVariation === null || assignedVariation === void 0 ? void 0 : assignedVariation.typedValue),
        };
        return internalAssignment.assignment.isExpectedType() ? internalAssignment : nullAssignment;
    }
    setLogger(logger) {
        this.assignmentLogger = logger;
        this.flushQueuedEvents(); // log any events that may have been queued while initializing
    }
    /**
     * Assignment cache methods.
     */
    disableAssignmentCache() {
        this.assignmentCache = undefined;
    }
    useNonExpiringAssignmentCache() {
        this.assignmentCache = new assignment_cache_1.NonExpiringAssignmentCache();
    }
    useLRUAssignmentCache(maxSize) {
        this.assignmentCache = new assignment_cache_1.LRUAssignmentCache(maxSize);
    }
    setIsGracefulFailureMode(gracefulFailureMode) {
        this.isGracefulFailureMode = gracefulFailureMode;
    }
    flushQueuedEvents() {
        var _a;
        const eventsToFlush = this.queuedEvents;
        this.queuedEvents = [];
        try {
            for (const event of eventsToFlush) {
                (_a = this.assignmentLogger) === null || _a === void 0 ? void 0 : _a.logAssignment(event);
            }
        }
        catch (error) {
            console.error(`[Eppo SDK] Error flushing assignment events: ${error.message}`);
        }
    }
    logAssignment(flagKey, allocationKey, variation, subjectKey, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    subjectAttributes = {}) {
        var _a, _b;
        if ((_a = this.assignmentCache) === null || _a === void 0 ? void 0 : _a.hasLoggedAssignment({
            flagKey,
            subjectKey,
            allocationKey,
            variationValue: variation,
        })) {
            return;
        }
        const event = {
            allocation: allocationKey,
            experiment: `${flagKey}-${allocationKey}`,
            featureFlag: flagKey,
            variation: variation.toString(),
            timestamp: new Date().toISOString(),
            subject: subjectKey,
            subjectAttributes,
        };
        // assignment logger may be null while waiting for initialization
        if (this.assignmentLogger == null) {
            this.queuedEvents.length < constants_1.MAX_EVENT_QUEUE_SIZE && this.queuedEvents.push(event);
            return;
        }
        try {
            this.assignmentLogger.logAssignment(event);
            (_b = this.assignmentCache) === null || _b === void 0 ? void 0 : _b.setLastLoggedAssignment({
                flagKey,
                subjectKey,
                allocationKey,
                variationValue: variation,
            });
        }
        catch (error) {
            console.error(`[Eppo SDK] Error logging assignment event: ${error.message}`);
        }
    }
    getSubjectVariationOverride(subjectKey, experimentConfig, expectedValueType) {
        const subjectHash = md5(subjectKey);
        const override = (experimentConfig === null || experimentConfig === void 0 ? void 0 : experimentConfig.overrides) && experimentConfig.overrides[subjectHash];
        const typedOverride = (experimentConfig === null || experimentConfig === void 0 ? void 0 : experimentConfig.typedOverrides) && experimentConfig.typedOverrides[subjectHash];
        return eppo_value_1.EppoValue.generateEppoValue(expectedValueType, override, typedOverride);
    }
    /**
     * This checks whether the subject is included in the experiment sample.
     * It is used to determine whether the subject should be assigned to a variant.
     * Given a hash function output (bucket), check whether the bucket is between 0 and exposure_percent * total_buckets.
     */
    isInExperimentSample(subjectKey, flagKey, experimentConfig, allocation) {
        const { subjectShards } = experimentConfig;
        const { percentExposure } = allocation;
        const shard = (0, shard_1.getShard)(`exposure-${subjectKey}-${flagKey}`, subjectShards);
        return shard <= percentExposure * subjectShards;
    }
}
exports.default = EppoClient;
//# sourceMappingURL=eppo-client.js.map