"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpRequestError = void 0;
const js_client_sdk_common_1 = require("@eppo/js-client-sdk-common");
const http_status_codes_1 = require("http-status-codes");
class HttpRequestError extends Error {
    constructor(message, status, isRecoverable) {
        super(message);
        this.message = message;
        this.status = status;
        this.isRecoverable = isRecoverable;
    }
}
exports.HttpRequestError = HttpRequestError;
// Extends HttpClient from common to surface errors for polling
class EppoHttpClient extends js_client_sdk_common_1.HttpClient {
    constructor(axiosInstance, sdkParams) {
        super(axiosInstance, sdkParams);
        this.isUnauthorized = false;
    }
    async get(resource) {
        try {
            return super.get(resource);
        }
        catch (error) {
            this._handleHttpError(error);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _handleHttpError(error) {
        var _a;
        const status = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status;
        this.isUnauthorized = status === http_status_codes_1.StatusCodes.UNAUTHORIZED;
        const isRecoverable = isHttpErrorRecoverable(status);
        throw new HttpRequestError(error.message, status, isRecoverable);
    }
}
exports.default = EppoHttpClient;
/**
 * Non-recoverable errors cause the polling to stop.
 */
function isHttpErrorRecoverable(status) {
    if (status >= 400 && status < 500) {
        return status === http_status_codes_1.StatusCodes.TOO_MANY_REQUESTS || status === http_status_codes_1.StatusCodes.REQUEST_TIMEOUT;
    }
    return true;
}
//# sourceMappingURL=http-client.js.map